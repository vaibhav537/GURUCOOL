import React, { useCallback, useEffect, useState } from "react"; //This line imports `useCallback`, `useState` , `useEffect` hooks from the React library, including React
import { useSocket } from "../context/SocketProvider"; //This line imports the useSocket function from a custom context called SocketProvider. The SocketProvider context is responsible for managing the socket connection between the client and server.
import peer from "../api/service/peer"; //This line imports an instance of the Peer class from the peer module. This module is responsible for setting up and managing the WebRTC peer-to-peer connection.
import ReactPlayer from "react-player"; //This line imports the ReactPlayer component from the react-player library. This library is used to play media files, such as audio and video, in the browser. And can be install by commmand `yarn add react-player`.

const Room = () => {
  // this is a socket server initilaization
  const socket = useSocket();
  const [remoteSocketId, setRemoteSocketId] = useState(null); //state for storing remote socket ids basically id of the another ser e=which connect to us
  const [myStream, setMyStream] = useState(); // state for storing the url of our socket basically storing the socket id of this end user
  const [remoteStream, setRemoteStream] = useState(); // state for storing the url of another user stream that will call on this

  // handling the user which will joined to this socket server and printing the email id of the joined user and setting remote socket id to socket id of the joined user
  const handleUserJoined = useCallback(({ email, id }) => {
    console.log(`Email ${email} joined room`);
    setRemoteSocketId(id);
  }, []);

  //This line declares a function named handleCallUser that uses the useCallback hook. The function is marked as async, which means that it can use the await keyword to wait for promises to resolve before continuing.

  const handleCallUser = useCallback(async () => {
    //This line uses the getUserMedia method from the navigator.mediaDevices API to request access to the user's camera and microphone. It returns a promise that resolves to a MediaStream object that represents the local user's media stream.

    const stream = await navigator.mediaDevices.getUserMedia({
      audio: true,
      video: true,
    });

    // This line uses a peer service to generate an offer message that will be sent to the remote peer. This offer message contains information about the local user's media stream, such as the type of media being offered, and the network capabilities of the sender.
    const offer = await peer.getOffer();

    // This line sends a socket message with the name user:call to the remote peer identified by the remoteSocketId variable. The payload of the message includes the offer message generated by the local user.
    socket.emit("user:call", { to: remoteSocketId, offer });

    // This line sets the myStream state variable to the MediaStream object returned by the getUserMedia method. This will cause the local user's video and audio to be displayed in the user interface.
    setMyStream(stream);
  }, [remoteSocketId, socket]); //This line specifies the dependencies of the handleCallUser function. The function will only be re-created if the remoteSocketId or socket variables change. This is done to optimize performance by preventing unnecessary re-renders of the component that uses this function.

  // This line declares a function named handleIncommingCall that uses the useCallback hook. This function is triggered when the user receives an incoming call from another user.
  const handleIncommingCall = useCallback(
    // This line defines an asynchronous function that takes an object with from and offer properties as its argument. The from property is the ID of the remote user who is making the call, and the offer property is the offer message sent by the remote user.
    async ({ from, offer }) => {
      // This line sets the remoteSocketId state variable to the ID of the remote user who is making the call. This ID is used to identify the remote peer and establish a WebRTC connection.
      setRemoteSocketId(from);
      // This line uses the getUserMedia method from the navigator.mediaDevices API to request access to the user's camera and microphone. It returns a promise that resolves to a MediaStream object that represents the local user's media stream.
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: true,
      });
      // This line uses the getUserMedia method from the navigator.mediaDevices API to request access to the user's camera and microphone. It returns a promise that resolves to a MediaStream object that represents the local user's media stream.
      setMyStream(stream);
      // This line logs a message to the console indicating that an incoming call has been received from the remote user with ID from, along with the offer message sent by that user.
      console.log(`Incoming Call`, from, offer);
      // This line uses the peer service to generate an answer message that will be sent back to the remote user. This answer message contains information about the local user's media stream, such as the type of media being offered, and the network capabilities of the sender.s
      const ans = await peer.getAnswer(offer);
      // This line sends a socket message with the name call:accepted to the remote user identified by the from variable. The payload of the message includes the ans message generated by the local user. This message indicates that the local user has accepted the incoming call and is ready to establish a WebRTC connection.
      socket.emit("call:accepted", { to: from, ans });
    },
    // This line specifies the dependencies of the handleIncommingCall function. The function will only be re-created if the socket variable changes. This is done to optimize performance by preventing unnecessary re-renders of the component that uses this function.
    [socket]
  );
  // This line declares a function named sendStreams that uses the useCallback hook. This function is responsible for sending the local user's media streams to the remote peer using the WebRTC addTrack method
  const sendStreams = useCallback(() => {
    // This line loops through each track in the myStream media stream object returned by getUserMedia.
    for (const track of myStream.getTracks()) {
      // This line uses the addTrack method of the peer object to add each track in the myStream object to the peer connection. This establishes a WebRTC data channel between the local user and the remote user.
      peer.peer.addTrack(track, myStream);
    }
    // This line specifies the dependencies of the sendStreams function. The function will only be re-created if the myStream variable changes. This is done to optimize performance by preventing unnecessary re-renders of the component that uses this function
  }, [myStream]);

  // This line declares a function named handleCallAccepted that uses the useCallback hook. This function is triggered when the local user receives a message from the remote peer indicating that the call has been accepted.
  const handleCallAccepted = useCallback(
    // This line defines a function that takes an object with from and ans properties as its argument. The from property is the ID of the remote user who accepted the call, and the ans property is the answer message sent by the remote user.
    ({ from, ans }) => {
      // This line uses the setLocalDescription method of the peer object to set the local user's description to the answer message sent by the remote user. This establishes a WebRTC connection between the local user and the remote user
      peer.setLocalDescription(ans);
      // This line logs a message to the console indicating that the call has been accepted.
      console.log("Call Accepted!");
      // This line calls the sendStreams function to send the local user's media streams to the remote peer using the WebRTC addTrack method.
      sendStreams();
    },
    // This line specifies the dependencies of the handleCallAccepted function. The function will only be re-created if the sendStreams function invoked. This is done to optimize performance by preventing unnecessary re-renders of the component that uses this function
    [sendStreams]
  );

  // This line declares a function named handleNegoNeeded that uses the useCallback hook. This function is responsible for initiating the WebRTC negotiation process when it is needed.
  // Negotiation in WebRTC is the process by which two peers establish a connection and agree on the parameters for their media streams. This negotiation process involves exchanging messages that describe the media formats and network characteristics that each peer supports.
  const handleNegoNeeded = useCallback(async () => {
    // This line uses the getOffer method of the peer object to generate a new offer message that will be sent to the remote peer. This message contains information about the local user's media streams and network capabilities.
    const offer = await peer.getOffer();
    // This line sends a socket message to the server indicating that negotiation is needed with the remote peer. The message includes the generated offer message and the ID of the remote peer.
    socket.emit("peer:nego:needed", { offer, to: remoteSocketId });
    // This line specifies the dependencies of the handleNegoNeeded function. The function will only be re-created if the remoteSocketId or socket variables change. This is done to optimize performance by preventing unnecessary re-renders of the component that uses this function.
  }, [remoteSocketId, socket]);

  // This line initiates a new useEffect hook. This hook will execute whenever the component it's defined in mounts or updates.
  useEffect(() => {
    // This line adds an event listener to the negotiationneeded event of the peer.peer object. When this event is triggered, the handleNegoNeeded function will be called.
    peer.peer.addEventListener("negotiationneeded", handleNegoNeeded);
    // This line defines a cleanup function that will be executed when the component unmounts or updates. This function removes the handleNegoNeeded event listener from the peer.peer object.
    return () => {
      peer.peer.removeEventListener("negotiationneeded", handleNegoNeeded);
    };
    // This line specifies the dependency array for the useEffect hook. The hook will re-run whenever the handleNegoNeeded function changes, which ensures that the latest version of the function is used as the event listener.
  }, [handleNegoNeeded]);

  // This line declares a new function called handleNegoNeedIncomming using the useCallback hook. This function will be called when a "peer:nego:needed" event is received from the signaling server.
  // Signaling servers are used in WebRTC to facilitate the initial communication between two peers before they can directly communicate with each other. This communication involves exchanging metadata and configuration data that is necessary for establishing a peer-to-peer connection.
  const handleNegoNeedIncomming = useCallback(
    // This line defines the function parameters as an object containing the from and offer properties. The from property specifies the ID of the remote peer who initiated the negotiation, and the offer property contains the offer created by the remote peer.
    async ({ from, offer }) => {
      // This line uses the peer.getAnswer() method to generate an answer to the offer received from the remote peer.
      const ans = await peer.getAnswer(offer);
      // This line emits a "peer:nego:done" event to the signaling server, passing the answer and the ID of the remote peer who initiated the negotiation as data. This event notifies the signaling server that this peer has finished the negotiation process and is now ready to establish a connection with the remote peer.
      socket.emit("peer:nego:done", { to: from, ans });
    },
    // This line specifies the dependencies for the useCallback hook. The function depends on the socket object to emit the "peer:nego:done" event to the signaling server.
    [socket]
  );

  // This code uses the `useCallback` hook to memoize the `handleNegoNeedFinal` function and optimize its performance. The function is called when a 'peer:nego:done' event is received from the signaling server.
  const handleNegoNeedFinal = useCallback(async ({ ans }) => 
    // This function sets the local session description of the peer object based on the answer passed in the `ans` parameter
    {
      // The `peer.setLocalDescription()` method sets the local session description of the peer object, which contains information about the media format and network capabilities of the local device. This information is used by the remote peer to establish a direct peer-to-peer connection with the local peer.
    await peer.setLocalDescription(ans);
    // The empty array passed as the second argument to `useCallback` indicates that the function does not depend on any variables from the component's state or props. 
  }, []);

  // This code attaches an event listener to the peer object when the component mounts
  // This code uses the `useEffect` hook to attach an event listener to the peer object when the component mounts. The event listener listens for a "track" event, which is triggered when the remote peer starts sending audio or video data to the local peer.
  useEffect(() => {
     // This event listener listens for a "track" event and sets the remote stream if it receives the event
    peer.peer.addEventListener("track", async (ev) => {
      // The `ev.streams` property contains an array of all the media streams received by the local peer, and `remoteStream[0]` selects the first stream from the array.
      const remoteStream = ev.streams;
      
      console.log("GOT TRACKS!!");
      // The `setRemoteStream` function is a state updater function that sets the `remoteStream` state variable with the newly received media stream.
      setRemoteStream(remoteStream[0]);
    });
    // The empty array passed as the second argument to `useEffect` indicates that this effect does not depend on any variables from the component's state or props.
  }, []);

  // This is a useEffect hook that sets up event listeners for incoming socket events and removes them when the component unmounts.
  // This is the beginning of the useEffect hook
  useEffect(() => {
    // These lines add event listeners to the socket object for incoming socket events. When an event of the specified type is received, the corresponding function will be called.
    socket.on("user:joined", handleUserJoined);
    socket.on("incomming:call", handleIncommingCall);
    socket.on("call:accepted", handleCallAccepted);
    socket.on("peer:nego:needed", handleNegoNeedIncomming);
    socket.on("peer:nego:final", handleNegoNeedFinal);
    // These lines remove the event listeners when the component unmounts. The off method is used to remove a specific event listener for a specific event type.
    return () => {
      socket.off("user:joined", handleUserJoined);
      socket.off("incomming:call", handleIncommingCall);
      socket.off("call:accepted", handleCallAccepted);
      socket.off("peer:nego:needed", handleNegoNeedIncomming);
      socket.off("peer:nego:final", handleNegoNeedFinal);
    };
    // The final parameter to the useEffect hook is an array of dependencies. This array specifies which variables the hook depends on. If any of these variables change, the hook will re-run. In this case, the hook depends on the socket object and several functions that are used as event listeners.
  }, [
    socket,
    handleUserJoined,
    handleIncommingCall,
    handleCallAccepted,
    handleNegoNeedIncomming,
    handleNegoNeedFinal,
  ]);
  return (
    // This creates a div element with a class of "text-black".
    <div className="text-black">
      {/* This adds an H1 heading element with the text "Room Page". */}
      <h1>Room Page</h1>
      {/* This adds an H4 heading element that displays either "Connected" or "No one in room", depending on whether a remote socket ID is present. */}
      <h4>{remoteSocketId ? "Connected" : "No one in room"}</h4>
      {/* This creates a button element that calls the "sendStreams" function when clicked, but only if "myStream" is not null or undefine  */}
      {myStream && <button onClick={sendStreams}>Send Stream</button>}
      {/* This creates a button element that calls the "handleCallUser" function when clicked, but only if a remote socket ID is present. */}
      {remoteSocketId && <button onClick={handleCallUser}>CALL</button>}
      {/* This conditionally renders an H1 element and a ReactPlayer component if "myStream" is not null or undefined. */}
      {myStream && (
        <>
          <h1>My Stream</h1>
          <ReactPlayer
            playing
            muted
            height="100px"
            width="200px"
            url={myStream}
          />
        </>
      )}
      {/* This conditionally renders an H1 element and a ReactPlayer component if "remoteStream" is not null or undefined. */}
      {remoteStream && (
        <>
          <h1>Remote Stream</h1>
          <ReactPlayer
            playing
            muted
            height="100px"
            width="200px"
            url={remoteStream}
          />
        </>
      )}
    </div>
  );
};

export default Room;
